---
title: "|  A/B Test Result Simulator"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    css: styles.css
    vertical_layout: scroll
    logo: logo-sm.png
    favicon: favicon.png
    includes:
      after_body: tracking.html
runtime: shiny
---

```{r setup}
library(tidyverse)
library(scales)

# Specify the base colors for A and B. These get used in various places
color_a <- "#00A2B1"
color_b <- "#9A258F"

```

Column {.sidebar data-width=400}
-------------------------------------

**Configuration**

Enter the (_**unknowable in reality!**_) conversion rates for **A** and **B** below (if we _only_ ran **A** or _only_ ran **B** for _all_ traffic for all time and _all other contributing factors were held constant_):

```{r}
# Conversion Rate for A
div(style="text-align: center;",
    div(style="display:inline-block; padding-right: 5px; font-weight: bold", "A:"),
    div(style="display:inline-block;", numericInput("rate_a", label = NULL, value = 2.0, width = "100px")),
    div(style="display:inline-block; padding-left: 5px; font-weight: bold", "%"))
```

```{r}
# Conversion Rate for B
div(style="text-align: center;",
    div(style="display:inline-block; padding-right: 5px; font-weight: bold", "B:"),
    div(style="display:inline-block;", numericInput("rate_b", label = NULL, value = 2.5, width = "100px")),
    div(style="display:inline-block; padding-left: 5px; font-weight: bold", "%"))
```

How many visit(or)s experienced **each variation** of the test?

```{r}
# Number of visitors
div(style="text-align: center;",
    div(style="display:inline-block",
        sliderInput("num_observations",
                    label = NULL,
                    min = 1000, max = 100000, value = 50000, step = 1000)))
```

**Annualizing Revenue Impact**

For how many days did the test run?

```{r}
# Test duration
div(style="text-align: center;",
    div(style="display:inline-block",
        numericInput("test_duration", 
                     label = NULL, value = 7,
                     width = "100px")))
```

What's the average order value (AOV) for the site?

```{r}
# Test duration
div(style="text-align: center;",
    div(style="display:inline-block",numericInput("aov", 
                                                  label = NULL, value = 200,
                                                  width = "100px")))
```

**Click Below to Simulate a Test**

```{r}
div(style="text-align: center;",
    div(style="display:inline-block",
        actionButton("run_test", "Run a Simulation!")))

```

Row
-----------------------------

### Overview

This simulator is designed to illustrate -- through calculations and simulation -- the difference between an _observed_ result in an A/B test and the _actual/true value_ _**(which is completely unknowable, but extremely useful to think about)**_.

Row {data-height=500}
-----------------------------

### Visualizing the Results

In the real world, we don't know the _actual_ values for **A** and **B**. We just know what we _observed_. If we did know the actual values, and we knew how many visitors we would have (which we've entered at left), then we could predict where the _observed_ values would fall. That's what the distributions are representing -- the magic of simulations in which we can see the normally unseeable.

```{r}

# Show the distributions
plotOutput("main_plot")

```

Row {data-height=260}
-----------------------------

### Assessing the Test Results

```{r results_assess}

uiOutput("summary_message")

```

### A Visual Comparison of the Lift %s

```{r conversion_rate_plot}

plotOutput("conv_rate_lift")
```

### Which Means We Have a...

```{r results_viz, fig.height = 1}

plotOutput("result_type")

```


Row {data-height=250} 
-----------------------------

### Annualizing Revenue Impact

We can use the traffic volume, test duration, and average order value, along with our conversion rate lift calculations to see what annualized revenue looks like. _Keep in mind that these only work if we hold every other revenue factor constant (and we still have a range even with that!)_

```{r annualization_assess}

div("The true annual revenue lift from running", em("B"), "instead of", em("A"), 
    "would be:", strong(textOutput("rev_actual", inline = TRUE)))
br()
div("The", strong("observed annual revenue lift"), "from running", em("B"), 
    "instead of", em("A"), "would be:", strong(textOutput("rev_observed", inline = TRUE)))
br()
div("The", strong("expected annual revenue lift RANGE"), "from running", em("B"), 
    "instead of", em("A"), "would be ", strong(textOutput("rev_range", inline = TRUE)))
br()
div("The calculation above is based on a 2-sample difference in proportions 95% confidence interval.")
```



```{r base_calculations}
# Calculations used multiple times .These are all reactive because they get repurposed a bit.

# Convert the entered rates to percents
rate_a_percent <- reactive({
  input$rate_a/100
})

rate_b_percent <- reactive({
  input$rate_b/100
})

# Calculate the standard deviation for A and B. Handy reference:
# https://stattrek.com/probability-distributions/binomial.aspx
sd_a <- reactive({
  sqrt(input$num_observations * rate_a_percent() * (1 - rate_a_percent())) / input$num_observations
})

sd_b <- reactive({
  sqrt(input$num_observations * rate_b_percent() * (1 - rate_b_percent())) / input$num_observations 
})

# Simulate a test -- simulate values for both A and for B
a_observed <- reactive({
  # For to re-run when the button is clicked
  input$run_test
  # Actually do a simulation
  rbinom(input$num_observations, 1, rate_a_percent()) %>% sum()/input$num_observations
})

b_observed <- reactive({
  # For to re-run when the button is clicked
  input$run_test
  # Actually do a simulation
  b_observed <- rbinom(input$num_observations, 1, rate_b_percent()) %>% sum()/input$num_observations
})

# Calculate the 95% confidence interval for A and for B based on the observed values. 
# See: https://sigmazone.com/binomial-confidence-intervals/ and
# http://statpages.info/confint.html. Probably could get these out of prop.test()
# instead.
xmin_a <- reactive({
  a_observed() - 1.96 * sqrt(a_observed() * (1 - a_observed()) / input$num_observations)
})

xmax_a <- reactive({
  a_observed() + 1.96 * sqrt(a_observed() * (1 - a_observed()) / input$num_observations)
})

xmin_b <- reactive({
  b_observed() - 1.96 * sqrt(b_observed() * (1 - b_observed()) / input$num_observations)
})

xmax_b <- reactive({
  b_observed() + 1.96 * sqrt(b_observed() * (1 - b_observed()) / input$num_observations)
})

# Calculate the 95% confidence interval for the 2-sample difference in proportions
# https://www.socscistatistics.com/confidenceinterval/default4.aspx.
# http://sphweb.bumc.bu.edu/otlt/MPH-Modules/BS/BS704_Confidence_Intervals/BS704_Confidence_Intervals5.html.
# It may be worth switching these to just use conf.int from prop.test() rather than
# hand-calculating.
min_lift_proportion <- reactive({
      min_lift_proportion <- b_observed() - a_observed() - 1.96 *
      sqrt((a_observed() * (1-a_observed()) + b_observed() * (1- b_observed())) / input$num_observations)
      
      cat("Min lift:", min_lift_proportion, "\n")
      min_lift_proportion
})

max_lift_proportion <- reactive({
      max_lift_proportion <- b_observed() - a_observed() + 1.96 *
      sqrt((a_observed() * (1-a_observed()) + b_observed() * (1- b_observed())) / input$num_observations)
      
      cat("Max lift:", max_lift_proportion, "\n")
      max_lift_proportion
})

# 2-sample test of proportions. We'll need this for the p-value and for
# the confidence interval
prop_test <- reactive({
  
# Run a 2-sample test of proportions. This is checking the null hypothesis
  # that B is NOT GREATER THAN A (a one-tailed test)
  prop_test <- prop.test(x = c(b_observed() * input$num_observations, 
                               a_observed() * input$num_observations), 
                         n = rep(input$num_observations,2),
              alternative = "two.sided")
  
  cat("Conf. interval:", prop_test$conf.int, "\n")
  prop_test
})

# Get the p-value
p_val <- reactive({

  p_val <- prop_test()$p.value
  
})

```

```{r main_plot}
# Build the main plot

output$main_plot <- renderPlot({
  
  # We want to keep the limits of the x axis constant regardless of the #
  # of observations, so calculate those limits based on 1000 and 3 * the
  # standard deviation. This way, the user will see the distribution physically 
  # get narrower or tighter as they adjust the # of observations.
  min_x <- min(
    rate_a_percent() - (sqrt(1000 * rate_a_percent() * (1 - rate_a_percent())) / 1000) * 3,
    rate_b_percent() - (sqrt(1000 * rate_b_percent() * (1 - rate_b_percent())) / 1000) * 3
  )
  
  max_x <- max(
    rate_a_percent() + (sqrt(1000 * rate_a_percent() * (1 - rate_a_percent())) / 1000) * 3,
    rate_b_percent() + (sqrt(1000 * rate_b_percent() * (1 - rate_b_percent())) / 1000) * 3
  )
  
  # go ahead and figure the offset to get the Actual line labels to be offset appropriatesly
  label_offset <- (max_x - min_x)/80
  
  # For visual clarity, we want to scale the y-axis so that the "top peak" stays
  # pretty much constant with enough room above it to put the labels. So, we're
  # going to use the same density function that gets used to draw the distributions
  # in the plot. The peak will be the mean, so we'll look at both means and see which
  # is greater.
  max_y <- max(dnorm(x = rate_a_percent(), mean = rate_a_percent(), sd = sd_a()),
               dnorm(x = rate_b_percent(), mean = rate_b_percent(), sd = sd_b()))
  
  #########
  # Simulate the tests
  #########
  
  # Get the simulated data from the reactive functions defined earlier
  a_observed <- a_observed()
  b_observed <- b_observed()
  xmin_a <- xmin_a()
  xmax_a <- xmax_a()
  xmin_b <- xmin_b()
  xmax_b <- xmax_b()
  
  # We want to display the values within the distribution, so calculate the top of the
  # curve using a_observed and then set a y that is 2/3 of that; so the same for B and set
  # it at 1/3. This will let the confidence interval lines not fall on top of each other.
  # Yeah. I'm kinda' proud of this little bit.
  a_observed_y <- dnorm(x = a_observed, mean = rate_a_percent(), sd = sd_a()) * 2/3
  b_observed_y <- dnorm(x = b_observed, mean = rate_b_percent(), sd = sd_b()) * 1/3
  
  # Create a data frame with the values
  observed_df <- data.frame(name = c("(Observed) A: ", "(Observed) B: "),
                            x = c(a_observed, b_observed),
                            xmin = c(xmin_a, xmin_b),          # Error bar min
                            xmax = c(xmax_a, xmax_b),          # Error bar max
                            y = c(a_observed_y, b_observed_y))
  
  ########
  # Create the main plot
  ########
  gg <- ggplot(data = data.frame(x = c(min_x, max_x)), aes(x)) +
    
    # Draw the two distributions
    stat_function(fun = dnorm, n = 300, geom = "area", 
                  args = list(mean = rate_a_percent(), sd = sd_a()),
                  fill = color_a, alpha = 0.1, color = "gray80",
                  linetype = "dotted", size = 1) +
    stat_function(fun = dnorm, n = 300, geom = "area",
                  args = list(mean = rate_b_percent(), sd = sd_b()),
                  fill = color_b, alpha = 0.1, color = "gray80",
                  linetype = "dotted", size = 1) +
    
    # Draw the two "actual" vertical lines and label them
    geom_vline(xintercept = rate_a_percent(), color = "gray30", linetype = "dashed", size = 1) +
    geom_text(aes(x = rate_a_percent() - label_offset, y = max_y * 1.05, 
                  label = paste0("(True!) A: ", format(rate_a_percent() * 100, nsmall = 1), "%")),
              hjust = 1, size = 5) +
    geom_vline(xintercept = rate_b_percent(), color = "gray30", linetype = "dashed", size = 1) +
    geom_text(aes(x = rate_b_percent() + label_offset, y = max_y * 1.05, 
                  label = paste0("(True!) B: ", format(rate_b_percent() * 100, nsmall = 1), "%")),
              hjust = 0, size = 5) +
    
    # Clean up the formatting
    scale_y_continuous(expand = c(0,0), limits = c(0, 1.1 * max_y), breaks = NULL) +
    theme_light() +
    theme(legend.position = "none",
          panel.border = element_blank(),
          panel.grid = element_blank(),
          plot.margin = margin(0,0,2.5,0, unit="cm"),   # Hacking around clipping in flexdashboard
          axis.title = element_blank(),
          axis.text = element_blank(),
          axis.line.x = element_line(color = "gray20"))
  
  # Add the simulated test results if any exist. If I try to do this with just a simple
  # 'if(input$run_test > 0)' and not an if/else, then the plot doesn't draw initially. I'm
  # not sure why.
  gg <- if(input$run_test == 0) {
    gg
  } else {
    gg +
      geom_errorbarh(mapping = aes(xmin = xmin, xmax = xmax, y = y), data = observed_df,
                     height = max_y/40, color = "gray30") +
      geom_point(mapping = aes(x=x, y=y, color = name, fill = name), data = observed_df, 
                 size = 4, shape = 23) +
      geom_label(mapping = aes(x=x, y=y + max_y/18, label = paste0(name, format(round(x * 100, 1), nsmall = 2), "%")),
                 size = 5, data = observed_df) +
      scale_fill_manual(values = c(color_a, color_b)) +
      scale_colour_manual(values = c(color_a, color_b))
    
  }
  
  # Return the plot
  gg
  
})

```

```{r assess_results}

# All the functions for assessing the results

# Significance Message
output$summary_message <- renderUI({
  
  # Return nothing if no test has been run
  if (input$run_test == 0)
    return()
  
  # Summarize the true and observed lifts
  summary_message <- div("The true (absolute) lift from", em("A"), "to", em("B"), "is",
                         strong(percent((input$rate_b - input$rate_a)/100, accuracy = 0.01)), ", but, in the",
                         "real world, that's not a value we know. We just know what the",
                         strong("observed lift"), "from", em("A"), "to", em("B"), "was in our ",
                         "simulation:", strong(percent(b_observed() - a_observed(), accuracy = 0.01)), ".")
  
  # Get the p-value
  p_val <- p_val()
  
  # Check for significance and write out the HTML summarizing it
  if(p_val < 0.05){
    sig_message <- div("The test", strong("IS significant"), " at a 95% confidence level (p-value =",
                       format(round(p_val, 4), nsmall = 4, scientific = FALSE), 
                       ", which is less than 0.05).", strong("We reject the null hypothesis that",
                                                             "there is no difference between A and B."))
  } else {
    sig_message <- div("The test is", strong("NOT significant"), " at a 95% confidence level (p-value =",
                       format(round(p_val, 4), nsmall = 4, scientific = FALSE), 
                       ", which is less than 0.05).", strong("We CANNOT reject the null hypothesis that",
                                                             "there is no difference between A and B."))
  }
  
  # Explanatory note
  exp_message <- div(em("The significance test run above was for a two-tailed test with",  
                        "a confidence level of 95%. We're not going to get into",
                        "the minutia behind that here."))
  
  # Build up all three statements
  summary_message <- list(summary_message, br(), sig_message, br(), exp_message)
  
  summary_message
})

# Visualize the actual vs. observed conversion rate lift
output$conv_rate_lift <- renderPlot({
  
   # Return nothing if no test has been run
  if (input$run_test == 0)
    return()
  
  # Make the actual lift label
  label_actual <- paste0("Actual Lift:\n",
                         percent(rate_b_percent() - rate_a_percent()))
  label_observed <- paste0("Observed Lift:\n",
                           percent(b_observed() - a_observed()),
                           " +/- ",
                           percent((max_lift_proportion() - min_lift_proportion())/2))
  
  # Build the data frame with the values we need to make the bar 
  # chart with error bars
  conv_rate_lift_df <- data.frame(x = c(label_actual, label_observed),
                                  y = c(rate_b_percent() - rate_a_percent(),
                                        b_observed() - a_observed()),
                                  ymin = c(NA, min_lift_proportion()),
                                  ymax = c(NA, max_lift_proportion()))
  
  # Build the plot
  gg <- ggplot(data = conv_rate_lift_df, 
               mapping = aes(x = x, y = y, fill = x, ymin = ymin, ymax = ymax)) +
    geom_bar(stat = "identity") +
    geom_errorbar(width = .06, color = "gray30") +
    geom_hline(aes(yintercept = 0)) +
    scale_fill_manual(values = c("#999999", "#00A2B1")) +
    scale_y_continuous(expand = c(0,0)) +
    theme_light() + theme(axis.title = element_blank(),
                          axis.text.y = element_blank(),
                          axis.text.x = element_text(size = 16, face="bold", 
                                                     margin = margin(0.3,0,0,0,"cm")),
                          panel.border = element_blank(),
                          panel.grid = element_blank(),
                          legend.position = "nono" )
  
  gg
  
})



# Recording if the type of result we've seen - true positive, false positive,...
output$result_type <- renderPlot({
  
  # Return nothing if no test has been run
  if (input$run_test == 0)
    return()
  
  # Get the p-value
  p_val <- p_val()
  
  # Start with a case where the "truth" is that there IS a difference
  if(input$rate_a != input$rate_b){
    # Check for significance
    if(p_val < 0.05){
      result_text <- "True Positive"
      result_fill <- "green"
    } else {
      result_text <- "False Negative"
      result_fill <- "red"
    }
  } else {
    # A and B are the same in truth
    # Check for significance
    if(p_val < 0.05){
      result_text <- "False Positive"
      result_fill <- "red"
    } else {
      result_text <- "True Negative"
      result_fill <- "green"
    }
  }
  
  # Make a data frame for a simple plot
  gg_data <- data.frame(x = 1, y = 1, result = result_text)
  
  # Make the plot
  gg <- ggplot(data = gg_data,
               mapping = aes(x = x, y = y, label = result)) +
    geom_text(size = 7) +
    theme_light() +
    theme(panel.background = element_rect(fill = result_fill),
          line = element_blank(),
          axis.text = element_blank(),
          axis.title = element_blank())
  gg
})

# True Annualized Revenue
output$rev_actual <- renderText({
  # Calculate annualized revenue lift. We're multiplying by 2 because the # of 
  # visit(ors) to each experience is only half of the total visit(or)s. Otherwise,
  # it's just straight math to get to a per day amount and then multiply by
  # 365. 
  rev_lift <- 2 * (rate_b_percent() - rate_a_percent()) * input$num_observations / input$test_duration * 365 * input$aov
  
  # Build the message
  rev_message <- paste0("$", format(rev_lift, big.mark = ",", nsmall = 0))
})

# Annualized Revenue Lift from Observed Results
output$rev_observed <- renderText({
  if(input$run_test == 0) {
    rev_message <- "not available"
  } else {
    # Calculate annualized revenue lift
    rev_lift <- 2 * (b_observed() - a_observed()) * input$num_observations / input$test_duration * 365 * input$aov
    # Build the message
    rev_message <- paste0("$", format(rev_lift, big.mark = ",", nsmall = 0))
  }
  rev_message
})

# Calculating based on confidence intervals
# Use a 2-sample test of proportions confidence interval formula:
# https://newonlinecourses.science.psu.edu/stat414/node/209/

output$rev_range <- renderText({
  if(input$run_test == 0) {
    return()
  } else {
    
    # Calculate the minimum proportional lift (e.g., if the observed A and B had a 5% lift,
    # this would calculate the +/- from that lift to get a 95% confidence interval for the
    # true lift)
    min_lift_proportion <- min_lift_proportion()
    max_lift_proportion <- max_lift_proportion()
       
    # Calculate the min and max lifts
    min_lift <- min_lift_proportion * input$num_observations / input$test_duration * 365 * input$aov
    max_lift <- max_lift_proportion * input$num_observations / input$test_duration * 365 * input$aov
    
    # Build the message
    rev_message <- paste0("$", format(round(min_lift,0), big.mark = ",", nsmall = 0), " to $",
                          format(round(max_lift,0), big.mark = ",", nsmall = 0))
  }
  rev_message
})

```



