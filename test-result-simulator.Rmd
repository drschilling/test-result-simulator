---
title: "Test Result Simulator"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    css: styles.css
    vertical_layout: scroll
    includes:
      after_body: tracking.html
runtime: shiny
---

### A/B Test Simulator

This simulator is designed to illustrate -- through calculations and simulation -- the difference between an _observed_ result in an A/B test and the _actual/true value_ _**(which is completely unknowable, but extremely useful to think about)**_.

```{r setup}
library(tidyverse)
library(scales)

# Specify the base colors for A and B. These get used in various places
color_a <- "#00A2B1"
color_b <- "#9A258F"

```

Row
-----------------------------

### 1. Enter the TRUE Conversion Rates

Enter the (_***unknowable in reality!***_) conversion rate for **A** below (if we _only_ ran **A** for ALL traffic from the end of the test for an entire year... and held everything else constant, because, well, _ceteris paribus_):

```{r}
# Conversion Rate for A
div(style="text-align: center;",
    div(style="display:inline-block;", numericInput("rate_a", label = NULL, value = 2.0, width = "100px")),
    div(style="display:inline-block; padding-left: 5px; font-weight: bold", "%"))
```

Now, enter the (_***unknowable in reality!**_) conversion rates for **B**:

```{r}
# Conversion Rate for B
div(style="text-align: center;",
    div(style="display:inline-block;", numericInput("rate_b", label = NULL, value = 2.2, width = "100px")),
    div(style="display:inline-block; padding-left: 5px; font-weight: bold", "%"))
```

### 2. Enter Test / Site Details

How many visit(or)s experienced **each variation** (we're assuming a 50/50 split here), **during the duration of the test**?

```{r}
# Number of visitors
sliderInput("num_observations",
            label = NULL,
            min = 1000, max = 100000, value = 5000, step = 1000)
```

For how many days did we run our (theoretical) test?

```{r}
# Test duration
numericInput("test_duration", 
             label = NULL, value = 7,
             width = "150px")
```

What's the average order value (AOV) for the site?

```{r}
# Test duration
numericInput("aov", 
             label = NULL, value = 200,
             width = "150px")
```

### 3. Let's Run a Test!

Click the button below to simulate a test in the universe we've described.

```{r}

actionButton("run_test", "Simulate a Test!")


```


Row
-----------------------------

### The Visual of What We've Specified Above -- the _TRUE_ conversion rate for both **A** and **B**

We don't know the _actual_ values for **A** and **B**. We just know what we _observed_. If we did know the actual values, and we knew how many visitors we would have (which we've entered above), then we can predict where the _observed_ values will fall. That's what the distributions are representing.

```{r}

# Show the distributions
plotOutput("main_plot")

```

Row
-----------------------------

### Assessing the Results

**The TRUE Annualized Impact of the Test**
Imagining a world where we could run **A** at 100% for a year and then go back and run **B** at 100% for a year, the total incremental revenue would be:





```{r calculations}

#####
# Calculations used multiple times
#####

# These are all reactive because they get repurposed a bit


#####
# Build the main plot
#####

output$main_plot <- renderPlot({
  
  # Convert the entered conversion rates to percentages
  rate_a_percent <- input$rate_a/100
  rate_b_percent <- input$rate_b/100
  
  # Calculate the standard deviation for A and B. Handy reference:
  # https://stattrek.com/probability-distributions/binomial.aspx
  sd_a <- sqrt(input$num_observations * rate_a_percent * (1 - rate_a_percent)) / input$num_observations 
  sd_b <- sqrt(input$num_observations * rate_b_percent * (1 - rate_b_percent)) / input$num_observations 
  
  # We want to keep the limits of the x axis constant regardless of the #
  # of observations, so calculate those limits based on 1000 and 3 * the
  # standard deviation. This way, the user will see the distribution physically 
  # get narrower or tighter as they adjust the # of observations.
  min_x <- min(
    rate_a_percent - (sqrt(1000 * rate_a_percent * (1 - rate_a_percent)) / 1000) * 3,
    rate_b_percent - (sqrt(1000 * rate_b_percent * (1 - rate_b_percent)) / 1000) * 3
  )
  
  max_x <- max(
    rate_a_percent + (sqrt(1000 * rate_a_percent * (1 - rate_a_percent)) / 1000) * 3,
    rate_b_percent + (sqrt(1000 * rate_b_percent * (1 - rate_b_percent)) / 1000) * 3
  )
  
  # go ahead and figure the offset to get the Actual line labels to be offset appropriatesly
  label_offset <- (max_x - min_x)/80
  
  # For visual clarity, we want to scale the y-axis so that the "top peak" stays
  # pretty much constant with enough room above it to put the labels. So, we're
  # going to use the same density function that gets used to draw the distributions
  # in the plot. The peak will be the mean, so we'll look at both means and see which
  # is greater.
  max_y <- max(dnorm(x = rate_a_percent, mean = rate_a_percent, sd = sd_a),
               dnorm(x = rate_b_percent, mean = rate_b_percent, sd = sd_b))
  
  #########
  # Simulate the tests
  #########
  
  # Simulate A and B
  a_observed <- rbinom(input$num_observations, 1, rate_a_percent) %>% sum()/input$num_observations
  b_observed <- rbinom(input$num_observations, 1, rate_b_percent) %>% sum()/input$num_observations
  
  # We want to display the values within the distribution, so calculate the top of the
  # curve using a_observed and then set a y that is 2/3 of that; so the same for B and set
  # it at 1/3. This will let the confidence interval lines not fall on top of each other.
  # Yeah. I'm kinda' proud of this little bit.
  a_observed_y <- dnorm(x = a_observed, mean = rate_a_percent, sd = sd_a) * 2/3
  b_observed_y <- dnorm(x = b_observed, mean = rate_b_percent, sd = sd_b) * 1/3
  
  # Create a data frame with the values
  observed_df <- data.frame(name = c("A - Observed", "B - Observed"),
                            x = c(a_observed, b_observed),
                            y = c(a_observed_y, b_observed_y))
  
  
  foo <- 3
  
  ########
  # Create the plot
  ########
  
  gg <- ggplot(data = data.frame(x = c(min_x, max_x)), aes(x)) +
    
    # Draw the two distributions
    stat_function(fun = dnorm, n = 300, geom = "area", 
                  args = list(mean = rate_a_percent, sd = sd_a),
                  fill = color_a, alpha = 0.1, color = "gray80",
                  linetype = "dotted", size = 1) +
    stat_function(fun = dnorm, n = 300, geom = "area",
                  args = list(mean = rate_b_percent, sd = sd_b),
                  fill = color_b, alpha = 0.1, color = "gray80",
                  linetype = "dotted", size = 1) +
    
    # Draw the two "actual" vertical lines and label them
    geom_vline(xintercept = rate_a_percent, color = "gray30", linetype = "dashed", size = 1) +
    geom_text(aes(x = rate_a_percent - label_offset, y = max_y * 1.05, 
                  label = paste0("(True!) A - ", format(rate_a_percent * 100, nsmall = 1), "% (A)")),
              hjust = 1, size = 5) +
    geom_vline(xintercept = rate_b_percent, color = "gray30", linetype = "dashed", size = 1) +
    geom_text(aes(x = rate_b_percent + label_offset, y = max_y * 1.05, 
                  label = paste0("(True!) B - ", format(rate_b_percent * 100, nsmall = 1), "% (A)")),
              hjust = 0, size = 5) +
    
    # Clean up the formatting
    scale_y_continuous(expand = c(0,0), limits = c(0, 1.1 * max_y), breaks = NULL) +
    theme_light() +
    theme(legend.position = "none",
          panel.border = element_blank(),
          panel.grid = element_blank(),
          plot.margin = margin(0,0,2.5,0, unit="cm"),   # Hacking around clipping in flexdashboard
          axis.title = element_blank(),
          axis.text = element_blank(),
          axis.line.x = element_line(color = "gray20"))
  
  # Add the simulated test results if any exist. If I try to do this with just a simple
  # 'if(input$run_test > 0)' and not an if/else, then the plot doesn't draw initially. I'm
  # not sure why.
  gg <- if(input$run_test == 0) {
    gg
  } else {
    gg +
      geom_point(mapping = aes(x=x, y=y, color = name, fill = name), data = observed_df, 
                 size = 4, shape = 23) +
      scale_fill_manual(values = c(color_a, color_b)) +
      scale_colour_manual(values = c(color_a, color_b))
    
  }

  # Return the plot
  gg
  
})


```




